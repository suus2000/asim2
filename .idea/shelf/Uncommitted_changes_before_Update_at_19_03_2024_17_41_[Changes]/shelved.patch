Index: EPA133a-G16-A3/model/components.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from mesa import Agent\r\nfrom enum import Enum\r\n\r\n\r\n# ---------------------------------------------------------------\r\nclass Infra(Agent):\r\n    \"\"\"\r\n    Base class for all infrastructure components\r\n\r\n    Attributes\r\n    __________\r\n    vehicle_count : int\r\n        the number of vehicles that are currently in/on (or totally generated/removed by)\r\n        this infrastructure component\r\n\r\n    length : float\r\n        the length in meters\r\n    ...\r\n\r\n    \"\"\"\r\n\r\n    def __init__(self, unique_id, model, length=0,\r\n                 name='Unknown', road_name='Unknown'):\r\n        super().__init__(unique_id, model)\r\n        self.length = length\r\n        self.name = name\r\n        self.road_name = road_name\r\n        self.vehicle_count = 0\r\n\r\n    def step(self):\r\n        pass\r\n\r\n    def __str__(self):\r\n        return type(self).__name__ + str(self.unique_id)\r\n\r\n\r\n# ---------------------------------------------------------------\r\nclass Bridge(Infra):\r\n    \"\"\"\r\n    Creates delay time\r\n\r\n    Attributes\r\n    __________\r\n    condition:\r\n        condition of the bridge\r\n\r\n    delay_time: int\r\n        the delay (in ticks) caused by this bridge\r\n    ...\r\n\r\n    \"\"\"\r\n\r\n    def __init__(self, unique_id, model, length=0,\r\n                 name='Unknown', road_name='Unknown', condition='Unknown'):\r\n        super().__init__(unique_id, model, length, name, road_name)\r\n\r\n        self.condition = condition\r\n        self.broken = False\r\n\r\n        # TODO\r\n        self.delay_time = self.random.randrange(0, 10)\r\n        # print(self.delay_time)\r\n\r\n    # TODO\r\n    def get_delay_time(self):\r\n        return self.delay_time\r\n\r\n\r\n# ---------------------------------------------------------------\r\nclass Link(Infra):\r\n    pass\r\n\r\n\r\n# ---------------------------------------------------------------\r\nclass Intersection(Infra):\r\n    pass\r\n\r\n\r\n# ---------------------------------------------------------------\r\nclass Sink(Infra):\r\n    \"\"\"\r\n    Sink removes vehicles\r\n\r\n    Attributes\r\n    __________\r\n    vehicle_removed_toggle: bool\r\n        toggles each time when a vehicle is removed\r\n    ...\r\n\r\n    \"\"\"\r\n    vehicle_removed_toggle = False\r\n\r\n    def remove(self, vehicle):\r\n        self.model.schedule.remove(vehicle)\r\n        self.vehicle_removed_toggle = not self.vehicle_removed_toggle\r\n        #print(str(self) + ' REMOVE ' + str(vehicle))\r\n\r\n\r\n# ---------------------------------------------------------------\r\n\r\nclass Source(Infra):\r\n    \"\"\"\r\n    Source generates vehicles\r\n\r\n    Class Attributes:\r\n    -----------------\r\n    truck_counter : int\r\n        the number of trucks generated by ALL sources. Used as Truck ID!\r\n\r\n    Attributes\r\n    __________\r\n    generation_frequency: int\r\n        the frequency (the number of ticks) by which a truck is generated\r\n\r\n    vehicle_generated_flag: bool\r\n        True when a Truck is generated in this tick; False otherwise\r\n    ...\r\n\r\n    \"\"\"\r\n\r\n    truck_counter = 0\r\n    generation_frequency = 5\r\n    vehicle_generated_flag = False\r\n\r\n    def step(self):\r\n        if self.model.schedule.steps % self.generation_frequency == 0:\r\n            self.generate_truck()\r\n        else:\r\n            self.vehicle_generated_flag = False\r\n\r\n    def generate_truck(self):\r\n        \"\"\"\r\n        Generates a truck, sets its path, increases the global and local counters\r\n        \"\"\"\r\n        try:\r\n            agent = Vehicle('Truck' + str(Source.truck_counter), self.model, self)\r\n            if agent:\r\n                self.model.schedule.add(agent)\r\n                agent.set_path()\r\n                Source.truck_counter += 1\r\n                self.vehicle_count += 1\r\n                self.vehicle_generated_flag = True\r\n                #print(str(self) + \" GENERATE \" + str(agent))\r\n        except Exception as e:\r\n            print(\"Oops!\", e.__class__, \"occurred.\")\r\n\r\n\r\n# ---------------------------------------------------------------\r\nclass SourceSink(Source, Sink):\r\n    \"\"\"\r\n    Generates and removes trucks\r\n    \"\"\"\r\n    pass\r\n\r\n\r\n# ---------------------------------------------------------------\r\nclass Vehicle(Agent):\r\n    \"\"\"\r\n\r\n    Attributes\r\n    __________\r\n    speed: float\r\n        speed in meter per minute (m/min)\r\n\r\n    step_time: int\r\n        the number of minutes (or seconds) a tick represents\r\n        Used as a base to change unites\r\n\r\n    state: Enum (DRIVE | WAIT)\r\n        state of the vehicle\r\n\r\n    location: Infra\r\n        reference to the Infra where the vehicle is located\r\n\r\n    location_offset: float\r\n        the location offset in meters relative to the starting point of\r\n        the Infra, which has a certain length\r\n        i.e. location_offset < length\r\n\r\n    path_ids: Series\r\n        the whole path (origin and destination) where the vehicle shall drive\r\n        It consists the Infras' uniques IDs in a sequential order\r\n\r\n    location_index: int\r\n        a pointer to the current Infra in \"path_ids\" (above)\r\n        i.e. the id of self.location is self.path_ids[self.location_index]\r\n\r\n    waiting_time: int\r\n        the time the vehicle needs to wait\r\n\r\n    generated_at_step: int\r\n        the timestamp (number of ticks) that the vehicle is generated\r\n\r\n    removed_at_step: int\r\n        the timestamp (number of ticks) that the vehicle is removed\r\n\r\n    waiting_time_agent: int\r\n        total waiting_time for one agent in the journey\r\n\r\n    travel_time: int\r\n        total travel_time from source to sink\r\n    \"\"\"\r\n\r\n    # 48 km/h translated into meter per min\r\n    speed = 48 * 1000 / 60\r\n    # One tick represents 1 minute\r\n    step_time = 1\r\n\r\n    class State(Enum):\r\n        DRIVE = 1\r\n        WAIT = 2\r\n\r\n    def __init__(self, unique_id, model, generated_by,\r\n                 location_offset=0, path_ids=None):\r\n        super().__init__(unique_id, model)\r\n        self.generated_by = generated_by\r\n        self.generated_at_step = model.schedule.steps\r\n        self.location = generated_by\r\n        self.location_offset = location_offset\r\n        self.pos = generated_by.pos\r\n        self.path_ids = path_ids\r\n        # default values\r\n        self.state = Vehicle.State.DRIVE\r\n        self.location_index = 0\r\n        self.waiting_time = 0\r\n        self.waiting_time_agent = 0\r\n\r\n        self.waited_at = None\r\n        self.removed_at_step = None\r\n\r\n        # Travel time\r\n        self.travel_time = 0\r\n\r\n    def __str__(self):\r\n        return \"Vehicle\" + str(self.unique_id) + \\\r\n               \" +\" + str(self.generated_at_step) + \" -\" + str(self.removed_at_step) + \\\r\n               \" \" + str(self.state) + '(' + str(self.waiting_time) + ') ' + \\\r\n               str(self.location) + '(' + str(self.location.vehicle_count) + ') ' + str(self.location_offset)\r\n\r\n    def set_path(self):\r\n        \"\"\"\r\n        Set the origin destination path of the vehicle\r\n        \"\"\"\r\n        self.path_ids = self.model.get_route(self.generated_by.unique_id)\r\n\r\n    def step(self):\r\n        \"\"\"\r\n        Vehicle waits or drives at each step\r\n        \"\"\"\r\n        # Increment travel time\r\n        self.travel_time += 1\r\n\r\n        if self.state == Vehicle.State.WAIT:\r\n            self.waiting_time = max(self.waiting_time - 1, 0)\r\n            if self.waiting_time == 0:\r\n                self.waited_at = self.location\r\n                self.state = Vehicle.State.DRIVE\r\n\r\n        if self.state == Vehicle.State.DRIVE:\r\n            self.drive()\r\n\r\n        \"\"\"\r\n        To print the vehicle trajectory at each step\r\n        \"\"\"\r\n        #print(self)\r\n\r\n    def drive(self):\r\n\r\n        # the distance that vehicle drives in a tick\r\n        # speed is global now: can change to instance object when individual speed is needed\r\n        distance = Vehicle.speed * Vehicle.step_time\r\n        distance_rest = self.location_offset + distance - self.location.length\r\n\r\n        if distance_rest > 0:\r\n            # go to the next object\r\n            self.drive_to_next(distance_rest)\r\n        else:\r\n            # remain on the same object\r\n            self.location_offset += distance\r\n\r\n    def drive_to_next(self, distance):\r\n        \"\"\"\r\n        vehicle shall move to the next object with the given distance\r\n        \"\"\"\r\n\r\n        self.location_index += 1\r\n        next_id = self.path_ids[self.location_index]\r\n        next_infra = self.model.schedule._agents[next_id]  # Access to protected member _agents\r\n\r\n        if isinstance(next_infra, Sink):\r\n            # arrive at the sink\r\n            self.arrive_at_next(next_infra, 0)\r\n\r\n            # When a vehicle has reached a sink, its data is considered for data collection\r\n            # which is a more efficient, and more accurate, way to calculate averages\r\n            self.model.total_travel_time.append(self.travel_time)\r\n            self.model.total_waiting_time.append(self.waiting_time_agent)\r\n            self.model.trucks_sink_counter += 1\r\n\r\n            self.removed_at_step = self.model.schedule.steps\r\n            self.location.remove(self)\r\n            return\r\n\r\n        elif isinstance(next_infra, Bridge):\r\n            self.waiting_time = self.get_delay_time(next_infra)\r\n            self.waiting_time_agent += self.waiting_time\r\n            if self.waiting_time > 0:\r\n                # arrive at the bridge and wait\r\n                self.arrive_at_next(next_infra, 0)\r\n                self.state = Vehicle.State.WAIT\r\n                return\r\n            # else, continue driving\r\n\r\n        if next_infra.length > distance:\r\n            # stay on this object:\r\n            self.arrive_at_next(next_infra, distance)\r\n        else:\r\n            # drive to next object:\r\n            self.drive_to_next(distance - next_infra.length)\r\n\r\n    def arrive_at_next(self, next_infra, location_offset):\r\n        \"\"\"\r\n        Arrive at next_infra with the given location_offset\r\n        \"\"\"\r\n        self.location.vehicle_count -= 1\r\n        self.location = next_infra\r\n        self.location_offset = location_offset\r\n        self.location.vehicle_count += 1\r\n\r\n    def get_delay_time(self, bridge):\r\n        \"\"\"\r\n        Delay time is calculated based on the conditions outlined in the assignment\r\n        The bridge is passed through as an argument\r\n        \"\"\"\r\n        # If the bridge is flagged, determine the delay_time, otherwise delay_time is 0\r\n        if bridge.broken == True:\r\n            if bridge.length > 200:\r\n                self.delay_time = self.random.triangular(60, 240, 120)\r\n            elif bridge.length > 50 and bridge.length <= 200:\r\n                self.delay_time = self.random.uniform(45, 90)\r\n            elif bridge.length > 10 and bridge.length <= 50:\r\n                self.delay_time = self.random.uniform(15, 60)\r\n            else:\r\n                self.delay_time = self.random.uniform(10, 20)\r\n\r\n        else:\r\n            self.delay_time = 0\r\n\r\n        return self.delay_time\r\n# EOF -----------------------------------------------------------\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/EPA133a-G16-A3/model/components.py b/EPA133a-G16-A3/model/components.py
--- a/EPA133a-G16-A3/model/components.py	(revision 6fac8107c7aa618ff3b6d2422503919c1fda283e)
+++ b/EPA133a-G16-A3/model/components.py	(date 1710788337894)
@@ -242,6 +242,7 @@
         Set the origin destination path of the vehicle
         """
         self.path_ids = self.model.get_route(self.generated_by.unique_id)
+        print("path_ids", self.path_ids)
 
     def step(self):
         """
@@ -286,6 +287,7 @@
         self.location_index += 1
         next_id = self.path_ids[self.location_index]
         next_infra = self.model.schedule._agents[next_id]  # Access to protected member _agents
+        next_infra = self.model.schedule._agents[next_id]  # Access to protected member _agents
 
         if isinstance(next_infra, Sink):
             # arrive at the sink
Index: EPA133a-G16-A3/model/model.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from mesa import Model\r\nfrom mesa.time import BaseScheduler\r\nfrom mesa.space import ContinuousSpace\r\nfrom components import Source, Sink, SourceSink, Bridge, Link, Intersection\r\nimport pandas as pd\r\nfrom collections import defaultdict\r\nimport networkx as nx\r\nimport matplotlib.pyplot as plt\r\n\r\n\r\n# ---------------------------------------------------------------\r\ndef set_lat_lon_bound(lat_min, lat_max, lon_min, lon_max, edge_ratio=0.02):\r\n    \"\"\"\r\n    Set the HTML continuous space canvas bounding box (for visualization)\r\n    give the min and max latitudes and Longitudes in Decimal Degrees (DD)\r\n\r\n    Add white borders at edges (default 2%) of the bounding box\r\n    \"\"\"\r\n\r\n    lat_edge = (lat_max - lat_min) * edge_ratio\r\n    lon_edge = (lon_max - lon_min) * edge_ratio\r\n\r\n    x_max = lon_max + lon_edge\r\n    y_max = lat_min - lat_edge\r\n    x_min = lon_min - lon_edge\r\n    y_min = lat_max + lat_edge\r\n    return y_min, y_max, x_min, x_max\r\n\r\n\r\n# ---------------------------------------------------------------\r\nclass BangladeshModel(Model):\r\n    \"\"\"\r\n    The main (top-level) simulation model\r\n\r\n    One tick represents one minute; this can be changed\r\n    but the distance calculation need to be adapted accordingly\r\n\r\n    Class Attributes:\r\n    -----------------\r\n    step_time: int\r\n        step_time = 1 # 1 step is 1 min\r\n\r\n    path_ids_dict: defaultdict\r\n        Key: (origin, destination)\r\n        Value: the shortest path (Infra component IDs) from an origin to a destination\r\n\r\n        Only straight paths in the Demo are added into the dict;\r\n        when there is a more complex network layout, the paths need to be managed differently\r\n\r\n    sources: list\r\n        all sources in the network\r\n\r\n    sinks: list\r\n        all sinks in the network\r\n\r\n    bridges: list\r\n        all bridges in the network\r\n\r\n    total_travel_time: list\r\n        the travel time of each agent that has reached the end of the road\r\n\r\n    truck_sink_counter: int\r\n        the number of trucks that reach the end of the road\r\n\r\n    total_waiting_time:\r\n        the total waiting time of each agent that has reached the end of the road\r\n    \"\"\"\r\n\r\n\r\n    step_time = 1\r\n\r\n    file_name = '../data/N1_N2_v1.csv'\r\n\r\n    def __init__(self, seed=None, x_max=500, y_max=500, x_min=0, y_min=0, scen_dict = {'A': 0, 'B': 0, 'C': 0, 'D': 0}):\r\n\r\n        self.schedule = BaseScheduler(self)\r\n        self.running = True\r\n        self.path_ids_dict = defaultdict(lambda: pd.Series())\r\n        self.space = None\r\n        self.sources = []\r\n        self.sinks = []\r\n        self.bridges = []\r\n\r\n        # DF of roads\r\n        self.road_df = None\r\n        self.road_list = []\r\n\r\n        self.total_travel_time = []\r\n        self.trucks_sink_counter = 0\r\n        self.total_waiting_time = []\r\n\r\n        self.amount_of_bridges = 0\r\n\r\n        self.generate_model()\r\n        self.generate_graph()\r\n        # The method break_bridges is called to determine which\r\n        # bridges should break with the scenario dictionary as input\r\n        self.break_bridges(scen_dict)\r\n\r\n    def generate_model(self):\r\n        \"\"\"\r\n        generate the simulation model according to the csv file component information\r\n\r\n        Warning: the labels are the same as the csv column labels\r\n        \"\"\"\r\n\r\n        df = pd.read_csv(self.file_name)\r\n        self.road_df = df\r\n\r\n\r\n        # a list of names of roads to be generated\r\n        # TODO You can also read in the road column to generate this list automatically\r\n        roads = ['R170', 'Z1044', 'N204', 'R240', 'R211', 'R241', 'Z1034', 'Z1402', 'N1', 'R301', 'Z1031', 'Z1048', 'R220', 'R203', 'N105', 'N102', 'N208', 'N104', 'N207', 'Z1005', 'R360', 'R151', 'N2', 'Z1042', 'R141']\r\n        #roads = ['N1', 'N2']\r\n        self.road_list = roads\r\n\r\n        #build and save networkx grah\r\n        df_objects_all = []\r\n        for road in roads:\r\n            # Select all the objects on a particular road in the original order as in the cvs\r\n            df_objects_on_road = df[df['road'] == road]\r\n            # acces paths from networkx\r\n\r\n            if not df_objects_on_road.empty:\r\n                df_objects_all.append(df_objects_on_road)\r\n\r\n                \"\"\"\r\n                Set the path \r\n                1. get the serie of object IDs on a given road in the cvs in the original order\r\n                2. add the (straight) path to the path_ids_dict\r\n                3. put the path in reversed order and reindex\r\n                4. add the path to the path_ids_dict so that the vehicles can drive backwards too\r\n                \"\"\"\r\n                path_ids = df_objects_on_road['id']\r\n                path_ids.reset_index(inplace=True, drop=True)\r\n                self.path_ids_dict[path_ids[0], path_ids.iloc[-1]] = path_ids\r\n                self.path_ids_dict[path_ids[0], None] = path_ids\r\n                path_ids = path_ids[::-1]\r\n                path_ids.reset_index(inplace=True, drop=True)\r\n                self.path_ids_dict[path_ids[0], path_ids.iloc[-1]] = path_ids\r\n                self.path_ids_dict[path_ids[0], None] = path_ids\r\n\r\n        # put back to df with selected roads so that min and max and be easily calculated\r\n        df = pd.concat(df_objects_all)\r\n        y_min, y_max, x_min, x_max = set_lat_lon_bound(\r\n            df['lat'].min(),\r\n            df['lat'].max(),\r\n            df['lon'].min(),\r\n            df['lon'].max(),\r\n            0.05\r\n        )\r\n\r\n        # ContinuousSpace from the Mesa package;\r\n        # not to be confused with the SimpleContinuousModule visualization\r\n        self.space = ContinuousSpace(x_max, y_max, True, x_min, y_min)\r\n\r\n        for df in df_objects_all:\r\n            for _, row in df.iterrows():  # index, row in ...\r\n\r\n                # create agents according to model_type\r\n                model_type = row['model_type'].strip()\r\n                agent = None\r\n\r\n                name = row['name']\r\n                if pd.isna(name):\r\n                    name = \"\"\r\n                else:\r\n                    name = name.strip()\r\n\r\n                if model_type == 'source':\r\n                    agent = Source(row['id'], self, row['length'], name, row['road'])\r\n                    self.sources.append(agent.unique_id)\r\n                elif model_type == 'sink':\r\n                    agent = Sink(row['id'], self, row['length'], name, row['road'])\r\n                    self.sinks.append(agent.unique_id)\r\n                elif model_type == 'sourcesink':\r\n                    agent = SourceSink(row['id'], self, row['length'], name, row['road'])\r\n                    self.sources.append(agent.unique_id)\r\n                    self.sinks.append(agent.unique_id)\r\n                elif model_type == 'bridge':\r\n                    # To check whether a bridge should break, its condition is needed\r\n                    agent = Bridge(row['id'], self, row['length'], name, row['road'], row['condition'])\r\n                    self.bridges.append(agent)\r\n                elif model_type == 'link':\r\n                    agent = Link(row['id'], self, row['length'], name, row['road'])\r\n                elif model_type == 'intersection':\r\n                    if not row['id'] in self.schedule._agents:\r\n                        agent = Intersection(row['id'], self, row['length'], name, row['road'])\r\n                if agent:\r\n                    self.schedule.add(agent)\r\n                    y = row['lat']\r\n                    x = row['lon']\r\n                    self.space.place_agent(agent, (x, y))\r\n                    agent.pos = (x, y)\r\n\r\n    def get_random_route(self, source):\r\n        \"\"\"\r\n        pick up a random route given an origin\r\n        \"\"\"\r\n        while True:\r\n            # different source and sink\r\n            sink = self.random.choice(self.sinks)\r\n            if sink is not source:\r\n                break\r\n        return self.path_ids_dict[source, sink]\r\n\r\n    # TODO\r\n    def get_route(self, source):\r\n        return self.get_straight_route(source)\r\n\r\n    def get_straight_route(self, source):\r\n        \"\"\"\r\n        pick up a straight route given an origin\r\n        \"\"\"\r\n        return self.path_ids_dict[source, None]\r\n\r\n\r\n    def step(self):\r\n        \"\"\"\r\n        Advance the simulation by one step.\r\n        \"\"\"\r\n        self.schedule.step()\r\n\r\n    def break_bridges(self, scenario_dict):\r\n        \"\"\"\r\n        Determines which bridge should break and flags them\r\n        \"\"\"\r\n        # Checks what bridges have a certain key (A,B,C,D) and adds them to a list\r\n        for key in scenario_dict:\r\n            bridges_condition_list = []\r\n            for bridge in self.bridges:\r\n                if bridge.condition == key:\r\n                    bridges_condition_list.append(bridge)\r\n\r\n            # Determines what amount of bridges of a certain condition should be broken with the scenario dictionary,\r\n            # then makes random choices and flags them\r\n            amount_bridges = len(bridges_condition_list)\r\n            amount_bridges_to_break = int((scenario_dict[key] / 100) * amount_bridges)\r\n            for i in range(amount_bridges_to_break):\r\n                bridge_to_break = self.random.choice(bridges_condition_list)\r\n                bridge_to_break.broken = True\r\n                bridges_condition_list.remove(bridge_to_break)\r\n\r\n    def get_data(self):\r\n        \"\"\"\r\n        Own data collector, more efficient as it generates data at end of model\r\n        \"\"\"\r\n        data_dict = {}\r\n        # Seed is being used as column name\r\n        seed = str(self._seed)\r\n        # Average travel time and average waiting time are being reported per run in one df per scenario\r\n        data_dict['Average Travel Time'] = sum(self.total_travel_time) / self.trucks_sink_counter\r\n        data_dict['Average Waiting Time'] = sum(self.total_waiting_time) / self.trucks_sink_counter\r\n        df = pd.DataFrame.from_dict(data_dict, orient='index', columns=[seed])\r\n        print('traveltime', self.total_travel_time)\r\n        print('waitingtime', self.total_waiting_time)\r\n        print('trucks', self.trucks_sink_counter)\r\n        return df\r\n\r\n    def generate_graph(self):\r\n        G = nx.Graph()\r\n        df = self.road_df\r\n        road_list = self.road_list\r\n        for road in road_list:\r\n            road_df = df.loc[df['road'] == road]\r\n            #print(road_df)\r\n            len_list = []\r\n            node_list_per_road = []\r\n            for _, row in road_df.iterrows():\r\n                #print(row['id'])\r\n                G.add_node(int(row['id']), pos=(row['lon'], row['lat']))\r\n                len_list.append(row['length'])\r\n                node_list_per_road.append(int(row['id']))\r\n            print('len_list', len_list)\r\n            print('node list', list(G.nodes))\r\n            for index, node in enumerate(node_list_per_road):\r\n                print('\\n')\r\n                print('index',index)\r\n                print('node',node)\r\n                print('length node list',len(node_list_per_road))\r\n                if index < (len(node_list_per_road)-1):\r\n                    print('next node', node_list_per_road[index + 1])\r\n                    print('len_list index value', len_list[index])\r\n                    G.add_weighted_edges_from([(node, node_list_per_road[index + 1],len_list[index])])\r\n\r\n        pos = nx.get_node_attributes(G, 'pos')\r\n        nx.draw(G, pos, with_labels = False, node_color = 'pink', node_size = 5)\r\n        plt.show()\r\n\r\n\r\n# EOF -----------------------------------------------------------\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/EPA133a-G16-A3/model/model.py b/EPA133a-G16-A3/model/model.py
--- a/EPA133a-G16-A3/model/model.py	(revision 6fac8107c7aa618ff3b6d2422503919c1fda283e)
+++ b/EPA133a-G16-A3/model/model.py	(date 1710790641959)
@@ -1,3 +1,5 @@
+import traceback
+
 from mesa import Model
 from mesa.time import BaseScheduler
 from mesa.space import ContinuousSpace
@@ -8,6 +10,7 @@
 import matplotlib.pyplot as plt
 
 
+
 # ---------------------------------------------------------------
 def set_lat_lon_bound(lat_min, lat_max, lon_min, lon_max, edge_ratio=0.02):
     """
@@ -69,9 +72,9 @@
 
     step_time = 1
 
-    file_name = '../data/N1_N2_v1.csv'
+    file_name = '../data/demo-4.csv'
 
-    def __init__(self, seed=None, x_max=500, y_max=500, x_min=0, y_min=0, scen_dict = {'A': 0, 'B': 0, 'C': 0, 'D': 0}):
+    def __init__(self, seed=None,   x_max=500, y_max=500, x_min=0, y_min=0, scen_dict = {'A': 0, 'B': 0, 'C': 0, 'D': 0}):
 
         self.schedule = BaseScheduler(self)
         self.running = True
@@ -92,10 +95,12 @@
         self.amount_of_bridges = 0
 
         self.generate_model()
-        self.generate_graph()
+
+        self.graph = self.generate_graph()
         # The method break_bridges is called to determine which
         # bridges should break with the scenario dictionary as input
         self.break_bridges(scen_dict)
+        #print(self.path_ids_dict)
 
     def generate_model(self):
         """
@@ -110,8 +115,8 @@
 
         # a list of names of roads to be generated
         # TODO You can also read in the road column to generate this list automatically
-        roads = ['R170', 'Z1044', 'N204', 'R240', 'R211', 'R241', 'Z1034', 'Z1402', 'N1', 'R301', 'Z1031', 'Z1048', 'R220', 'R203', 'N105', 'N102', 'N208', 'N104', 'N207', 'Z1005', 'R360', 'R151', 'N2', 'Z1042', 'R141']
-        #roads = ['N1', 'N2']
+        #roads = ['R170', 'Z1044', 'N204', 'R240', 'R211', 'R241', 'Z1034', 'Z1402', 'N1', 'R301', 'Z1031', 'Z1048', 'R220', 'R203', 'N105', 'N102', 'N208', 'N104', 'N207', 'Z1005', 'R360', 'R151', 'N2', 'Z1042', 'R141']
+        roads = ['N1', 'N2']
         self.road_list = roads
 
         #build and save networkx grah
@@ -202,11 +207,26 @@
             sink = self.random.choice(self.sinks)
             if sink is not source:
                 break
+        if (source, sink) not in self.path_ids_dict.keys():
+            print("we gaan van ", source, "naar ", sink)
+            try:
+                shortest_path = nx.shortest_path(self.graph, source=source, target=sink)
+                route = pd.Series(shortest_path)
+                self.path_ids_dict[(source, sink)] = route
+                print(self.path_ids_dict[source, sink])
+            except nx.NetworkXNoPath:
+                traceback.print_exc()
+                print("No path found")
+        else:
+            print("leuk")
+            return self.path_ids_dict[source, sink]
+
         return self.path_ids_dict[source, sink]
 
     # TODO
     def get_route(self, source):
-        return self.get_straight_route(source)
+
+        return self.get_random_route(source)
 
     def get_straight_route(self, source):
         """
@@ -271,21 +291,24 @@
                 G.add_node(int(row['id']), pos=(row['lon'], row['lat']))
                 len_list.append(row['length'])
                 node_list_per_road.append(int(row['id']))
-            print('len_list', len_list)
-            print('node list', list(G.nodes))
+            #print('len_list', len_list)
+            #print('node list', list(G.nodes))
             for index, node in enumerate(node_list_per_road):
-                print('\n')
-                print('index',index)
-                print('node',node)
-                print('length node list',len(node_list_per_road))
+                #print('\n')
+                #print('index',index)
+                #print('node',node)
+                #print('length node list',len(node_list_per_road))
                 if index < (len(node_list_per_road)-1):
-                    print('next node', node_list_per_road[index + 1])
-                    print('len_list index value', len_list[index])
+                    #print('next node', node_list_per_road[index + 1])
+                    #print('len_list index value', len_list[index])
                     G.add_weighted_edges_from([(node, node_list_per_road[index + 1],len_list[index])])
-
         pos = nx.get_node_attributes(G, 'pos')
-        nx.draw(G, pos, with_labels = False, node_color = 'pink', node_size = 5)
+        nx.draw(G, pos, with_labels=False, node_color='pink', node_size=5)
         plt.show()
+        print("de graaf is", G)
+        return G
+
+
 
 
 # EOF -----------------------------------------------------------
