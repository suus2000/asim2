Index: EPA133a-G16-A3/model/model.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import traceback\r\n\r\nfrom mesa import Model\r\nfrom mesa.time import BaseScheduler\r\nfrom mesa.space import ContinuousSpace\r\nfrom components import Source, Sink, SourceSink, Bridge, Link, Intersection\r\nimport pandas as pd\r\nfrom collections import defaultdict\r\nimport networkx as nx\r\nimport matplotlib.pyplot as plt\r\n\r\n\r\n\r\n# ---------------------------------------------------------------\r\ndef set_lat_lon_bound(lat_min, lat_max, lon_min, lon_max, edge_ratio=0.02):\r\n    \"\"\"\r\n    Set the HTML continuous space canvas bounding box (for visualization)\r\n    give the min and max latitudes and Longitudes in Decimal Degrees (DD)\r\n\r\n    Add white borders at edges (default 2%) of the bounding box\r\n    \"\"\"\r\n\r\n    lat_edge = (lat_max - lat_min) * edge_ratio\r\n    lon_edge = (lon_max - lon_min) * edge_ratio\r\n\r\n    x_max = lon_max + lon_edge\r\n    y_max = lat_min - lat_edge\r\n    x_min = lon_min - lon_edge\r\n    y_min = lat_max + lat_edge\r\n    return y_min, y_max, x_min, x_max\r\n\r\n\r\n# ---------------------------------------------------------------\r\nclass BangladeshModel(Model):\r\n    \"\"\"\r\n    The main (top-level) simulation model\r\n\r\n    One tick represents one minute; this can be changed\r\n    but the distance calculation need to be adapted accordingly\r\n\r\n    Class Attributes:\r\n    -----------------\r\n    step_time: int\r\n        step_time = 1 # 1 step is 1 min\r\n\r\n    path_ids_dict: defaultdict\r\n        Key: (origin, destination)\r\n        Value: the shortest path (Infra component IDs) from an origin to a destination\r\n\r\n        Only straight paths in the Demo are added into the dict;\r\n        when there is a more complex network layout, the paths need to be managed differently\r\n\r\n    sources: list\r\n        all sources in the network\r\n\r\n    sinks: list\r\n        all sinks in the network\r\n\r\n    bridges: list\r\n        all bridges in the network\r\n\r\n    total_travel_time: list\r\n        the travel time of each agent that has reached the end of the road\r\n\r\n    truck_sink_counter: int\r\n        the number of trucks that reach the end of the road\r\n\r\n    total_waiting_time:\r\n        the total waiting time of each agent that has reached the end of the road\r\n    \"\"\"\r\n\r\n\r\n    step_time = 1\r\n\r\n    file_name = '../data/demo-4.csv'\r\n\r\n    def __init__(self, seed=None,   x_max=500, y_max=500, x_min=0, y_min=0, scen_dict = {'A': 0, 'B': 0, 'C': 0, 'D': 0}):\r\n\r\n        self.schedule = BaseScheduler(self)\r\n        self.running = True\r\n        self.path_ids_dict = defaultdict(lambda: pd.Series())\r\n        self.space = None\r\n        self.sources = []\r\n        self.sinks = []\r\n        self.bridges = []\r\n\r\n        # DF of roads\r\n        self.road_df = None\r\n        self.road_list = []\r\n\r\n        self.total_travel_time = []\r\n        self.trucks_sink_counter = 0\r\n        self.total_waiting_time = []\r\n\r\n        self.amount_of_bridges = 0\r\n\r\n        self.generate_model()\r\n\r\n        self.graph = self.generate_graph()\r\n        # The method break_bridges is called to determine which\r\n        # bridges should break with the scenario dictionary as input\r\n        self.break_bridges(scen_dict)\r\n        #print(self.path_ids_dict)\r\n\r\n    def generate_model(self):\r\n        \"\"\"\r\n        generate the simulation model according to the csv file component information\r\n\r\n        Warning: the labels are the same as the csv column labels\r\n        \"\"\"\r\n\r\n        df = pd.read_csv(self.file_name)\r\n        self.road_df = df\r\n\r\n\r\n        # a list of names of roads to be generated\r\n        # TODO You can also read in the road column to generate this list automatically\r\n        #roads = ['R170', 'Z1044', 'N204', 'R240', 'R211', 'R241', 'Z1034', 'Z1402', 'N1', 'R301', 'Z1031', 'Z1048', 'R220', 'R203', 'N105', 'N102', 'N208', 'N104', 'N207', 'Z1005', 'R360', 'R151', 'N2', 'Z1042', 'R141']\r\n        roads = ['N1', 'N2']\r\n        self.road_list = roads\r\n\r\n        #build and save networkx grah\r\n        df_objects_all = []\r\n        for road in roads:\r\n            # Select all the objects on a particular road in the original order as in the cvs\r\n            df_objects_on_road = df[df['road'] == road]\r\n            # acces paths from networkx\r\n\r\n            if not df_objects_on_road.empty:\r\n                df_objects_all.append(df_objects_on_road)\r\n\r\n                \"\"\"\r\n                Set the path \r\n                1. get the serie of object IDs on a given road in the cvs in the original order\r\n                2. add the (straight) path to the path_ids_dict\r\n                3. put the path in reversed order and reindex\r\n                4. add the path to the path_ids_dict so that the vehicles can drive backwards too\r\n                \"\"\"\r\n                path_ids = df_objects_on_road['id']\r\n                path_ids.reset_index(inplace=True, drop=True)\r\n                self.path_ids_dict[path_ids[0], path_ids.iloc[-1]] = path_ids\r\n                self.path_ids_dict[path_ids[0], None] = path_ids\r\n                path_ids = path_ids[::-1]\r\n                path_ids.reset_index(inplace=True, drop=True)\r\n                self.path_ids_dict[path_ids[0], path_ids.iloc[-1]] = path_ids\r\n                self.path_ids_dict[path_ids[0], None] = path_ids\r\n\r\n        # put back to df with selected roads so that min and max and be easily calculated\r\n        df = pd.concat(df_objects_all)\r\n        y_min, y_max, x_min, x_max = set_lat_lon_bound(\r\n            df['lat'].min(),\r\n            df['lat'].max(),\r\n            df['lon'].min(),\r\n            df['lon'].max(),\r\n            0.05\r\n        )\r\n\r\n        # ContinuousSpace from the Mesa package;\r\n        # not to be confused with the SimpleContinuousModule visualization\r\n        self.space = ContinuousSpace(x_max, y_max, True, x_min, y_min)\r\n\r\n        for df in df_objects_all:\r\n            for _, row in df.iterrows():  # index, row in ...\r\n\r\n                # create agents according to model_type\r\n                model_type = row['model_type'].strip()\r\n                agent = None\r\n\r\n                name = row['name']\r\n                if pd.isna(name):\r\n                    name = \"\"\r\n                else:\r\n                    name = name.strip()\r\n\r\n                if model_type == 'source':\r\n                    agent = Source(row['id'], self, row['length'], name, row['road'])\r\n                    self.sources.append(agent.unique_id)\r\n                elif model_type == 'sink':\r\n                    agent = Sink(row['id'], self, row['length'], name, row['road'])\r\n                    self.sinks.append(agent.unique_id)\r\n                elif model_type == 'sourcesink':\r\n                    agent = SourceSink(row['id'], self, row['length'], name, row['road'])\r\n                    self.sources.append(agent.unique_id)\r\n                    self.sinks.append(agent.unique_id)\r\n                elif model_type == 'bridge':\r\n                    # To check whether a bridge should break, its condition is needed\r\n                    agent = Bridge(row['id'], self, row['length'], name, row['road'], row['condition'])\r\n                    self.bridges.append(agent)\r\n                elif model_type == 'link':\r\n                    agent = Link(row['id'], self, row['length'], name, row['road'])\r\n                elif model_type == 'intersection':\r\n                    if not row['id'] in self.schedule._agents:\r\n                        agent = Intersection(row['id'], self, row['length'], name, row['road'])\r\n                if agent:\r\n                    self.schedule.add(agent)\r\n                    y = row['lat']\r\n                    x = row['lon']\r\n                    self.space.place_agent(agent, (x, y))\r\n                    agent.pos = (x, y)\r\n\r\n    def get_random_route(self, source):\r\n        \"\"\"\r\n        pick up a random route given an origin\r\n        \"\"\"\r\n        while True:\r\n            # different source and sink\r\n            sink = self.random.choice(self.sinks)\r\n            if sink is not source:\r\n                break\r\n        if (source, sink) not in self.path_ids_dict.keys():\r\n            print(\"we gaan van \", source, \"naar \", sink)\r\n            try:\r\n                shortest_path = nx.shortest_path(self.graph, source=source, target=sink)\r\n                route = pd.Series(shortest_path)\r\n                self.path_ids_dict[(source, sink)] = route\r\n                print(\"the path is\", self.path_ids_dict[source, sink])\r\n            except nx.NetworkXNoPath:\r\n                traceback.print_exc()\r\n                print(\"No path found\")\r\n        else:\r\n            #print(\"leuk\")\r\n            return self.path_ids_dict[source, sink]\r\n\r\n        return self.path_ids_dict[source, sink]\r\n\r\n    # TODO\r\n    def get_route(self, source):\r\n\r\n        return self.get_random_route(source)\r\n\r\n    def get_straight_route(self, source):\r\n        \"\"\"\r\n        pick up a straight route given an origin\r\n        \"\"\"\r\n        return self.path_ids_dict[source, None]\r\n\r\n\r\n    def step(self):\r\n        \"\"\"\r\n        Advance the simulation by one step.\r\n        \"\"\"\r\n        self.schedule.step()\r\n\r\n    def break_bridges(self, scenario_dict):\r\n        \"\"\"\r\n        Determines which bridge should break and flags them\r\n        \"\"\"\r\n        # Checks what bridges have a certain key (A,B,C,D) and adds them to a list\r\n        for key in scenario_dict:\r\n            bridges_condition_list = []\r\n            for bridge in self.bridges:\r\n                if bridge.condition == key:\r\n                    bridges_condition_list.append(bridge)\r\n\r\n            # Determines what amount of bridges of a certain condition should be broken with the scenario dictionary,\r\n            # then makes random choices and flags them\r\n            amount_bridges = len(bridges_condition_list)\r\n            amount_bridges_to_break = int((scenario_dict[key] / 100) * amount_bridges)\r\n            for i in range(amount_bridges_to_break):\r\n                bridge_to_break = self.random.choice(bridges_condition_list)\r\n                bridge_to_break.broken = True\r\n                bridges_condition_list.remove(bridge_to_break)\r\n\r\n    def get_data(self):\r\n        \"\"\"\r\n        Own data collector, more efficient as it generates data at end of model\r\n        \"\"\"\r\n        data_dict = {}\r\n        # Seed is being used as column name\r\n        seed = str(self._seed)\r\n        # Average travel time and average waiting time are being reported per run in one df per scenario\r\n        data_dict['Average Travel Time'] = sum(self.total_travel_time) / self.trucks_sink_counter\r\n        data_dict['Average Waiting Time'] = sum(self.total_waiting_time) / self.trucks_sink_counter\r\n        df = pd.DataFrame.from_dict(data_dict, orient='index', columns=[seed])\r\n        print('traveltime', self.total_travel_time)\r\n        print('waitingtime', self.total_waiting_time)\r\n        print('trucks', self.trucks_sink_counter)\r\n        return df\r\n\r\n    def generate_graph(self):\r\n        G = nx.Graph()\r\n        df = self.road_df\r\n        road_list = self.road_list\r\n        for road in road_list:\r\n            road_df = df.loc[df['road'] == road]\r\n            #print(road_df)\r\n            len_list = []\r\n            node_list_per_road = []\r\n            for _, row in road_df.iterrows():\r\n                #print(row['id'])\r\n                G.add_node(int(row['id']), pos=(row['lon'], row['lat']))\r\n                len_list.append(row['length'])\r\n                node_list_per_road.append(int(row['id']))\r\n            #print('len_list', len_list)\r\n            #print('node list', list(G.nodes))\r\n            for index, node in enumerate(node_list_per_road):\r\n                #print('\\n')\r\n                #print('index',index)\r\n                #print('node',node)\r\n                #print('length node list',len(node_list_per_road))\r\n                if index < (len(node_list_per_road)-1):\r\n                    #print('next node', node_list_per_road[index + 1])\r\n                    #print('len_list index value', len_list[index])\r\n                    G.add_weighted_edges_from([(node, node_list_per_road[index + 1],len_list[index])])\r\n        pos = nx.get_node_attributes(G, 'pos')\r\n        nx.draw(G, pos, with_labels=False, node_color='pink', node_size=5)\r\n        plt.show()\r\n        print(\"de graaf is\", G)\r\n        return G\r\n\r\n\r\n\r\n\r\n# EOF -----------------------------------------------------------\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/EPA133a-G16-A3/model/model.py b/EPA133a-G16-A3/model/model.py
--- a/EPA133a-G16-A3/model/model.py	(revision fb1f370d7b82175c41e495fc9475201cdd4d1787)
+++ b/EPA133a-G16-A3/model/model.py	(date 1710876696939)
@@ -72,7 +72,7 @@
 
     step_time = 1
 
-    file_name = '../data/demo-4.csv'
+    file_name = '../data/N1_N2_v2.csv'
 
     def __init__(self, seed=None,   x_max=500, y_max=500, x_min=0, y_min=0, scen_dict = {'A': 0, 'B': 0, 'C': 0, 'D': 0}):
 
@@ -115,8 +115,8 @@
 
         # a list of names of roads to be generated
         # TODO You can also read in the road column to generate this list automatically
-        #roads = ['R170', 'Z1044', 'N204', 'R240', 'R211', 'R241', 'Z1034', 'Z1402', 'N1', 'R301', 'Z1031', 'Z1048', 'R220', 'R203', 'N105', 'N102', 'N208', 'N104', 'N207', 'Z1005', 'R360', 'R151', 'N2', 'Z1042', 'R141']
-        roads = ['N1', 'N2']
+        roads = ['R170', 'Z1044', 'N204', 'R240', 'R211', 'R241', 'Z1034', 'Z1402', 'N1', 'R301', 'Z1031', 'Z1048', 'R220', 'R203', 'N105', 'N102', 'N208', 'N104', 'N207', 'Z1005', 'R360', 'R151', 'N2', 'Z1042', 'R141']
+        #roads = ['N1', 'N2']
         self.road_list = roads
 
         #build and save networkx grah
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"Black\">\r\n    <option name=\"sdkName\" value=\"Python 3.11\" />\r\n  </component>\r\n  <component name=\"ProjectRootManager\" version=\"2\" project-jdk-name=\"Python 3.11\" project-jdk-type=\"Python SDK\" />\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
--- a/.idea/misc.xml	(revision fb1f370d7b82175c41e495fc9475201cdd4d1787)
+++ b/.idea/misc.xml	(date 1710876655978)
@@ -3,5 +3,5 @@
   <component name="Black">
     <option name="sdkName" value="Python 3.11" />
   </component>
-  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.11" project-jdk-type="Python SDK" />
+  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.11 (asim2)" project-jdk-type="Python SDK" />
 </project>
\ No newline at end of file
